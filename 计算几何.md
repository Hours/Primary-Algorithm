Primary-Algorithm
=================
Get accurent results

计算几何：
----------------------
###误差修正
		const double eps = 1e-8;
		int cmp(double x){
			if( fabs(x) < eps ) return 0;
			if( x > 0 ) return 1;
			return -1;
		}
### 计算几何点类
		const double pi = acos(-1.0);
		struct point{
			double x, y;
			point(){
				double x, y;
				point(){}
				point(double a, double b):x(a), y(b){}
				friend point operator + ( const point &a, const point &b ){
					return point ( a.x+b.x, a.y+b.y );
				}
				friend point operator - ( point a, point b ){
			                return point( a.x-b.x, a.y-b.y );
			        }
			        friend point operator * ( double c, point a ){
			                return point( a.x * c, a.y * c );
			        }
			        friend point operator / ( point a, double c ){
			                return point( a.x/c, a.y/c );
			        }
			        //a、b两个点的叉积
			        friend double det( const point &a, const point &b ){
			              return a.x * b.y - a.y * b.x;
			        }
			        //从第一象限开始逆时针极角排序
			        friend bool operator < ( const point &a, const point &b ){
			               int ret = cmp( det( a, b ) );	//det < 0 =〉逆时针
			               if( a.y * b.y < 0 )	
			                        return ret < 0 && a.y < b.y;
			               return ret < 0 || ret == 0 && cmp( a.x - b.x) < 0;
			        }
			}
		}
		//点积
		double dot( point a, point b ){
		        return a.x * b.x + a.y * b.y;
		}
		//两个点的距离
		double norm( const point &a ){
		    return sqrt(a.x*a.x + a.y*a.y);
		}
		//点到线段st的最短距离
		double dist( const point &p, const point &s, const point &t ){
		    if( cmp(dot(p-s, t-s)) < 0 ) return norm( p-s );
		    if( cmp(dot(p-t, s-t)) < 0 ) return norm( p-t );
		    return fabs(det( p-s, p-t ) / norm(s-t));
		}
		//向量oa绕原点逆时针旋转t（弧度）
		point rotatep( const point &a, double t ){
		        double tx = a.x, ty = a.y;
		        return point(tx*cos(t)-ty*sin(t), tx*sin(t)+ty*cos(t));
		}
		point ProjLine( point p, point s, point t ){
			double r = dot((t-s), (p-s)) / dot( t-s, t-s );
			return s+r*(t-s);
		}
		//两条线段的交点
		point makepoint( line l1, line l2 ){
		        double s1, s2;
		        s1 = det( l1.s - l2.t, l2.t - l2.s );
		        s2 = det( l1.t - l2.t, l2.t - l2.s );
		        return ( s1 * l1.t - s2 * l1.s ) / ( s1 - s2 );
		}
