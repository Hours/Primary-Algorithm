Primary-Algorithm
=================
Get accurent results

计算几何：
----------------------
###误差修正
		const double eps = 1e-8;
		int cmp(double x){
			if( fabs(x) < eps ) return 0;
			if( x > 0 ) return 1;
			return -1;
		}
### 点类
		const double pi = acos(-1.0);
		struct point{
			double x, y;
			point(){
				double x, y;
				point(){}
				point(double a, double b):x(a), y(b){}
				friend point operator + ( const point &a, const point &b ){
					return point ( a.x+b.x, a.y+b.y );
				}
				friend point operator - ( point a, point b ){
			                return point( a.x-b.x, a.y-b.y );
			        }
			        friend point operator * ( double c, point a ){
			                return point( a.x * c, a.y * c );
			        }
			        friend point operator / ( point a, double c ){
			                return point( a.x/c, a.y/c );
			        }
			        //a、b两个点的叉积(具有矢量，符号代表逆时针、平行四边形面积)
			        friend double det( const point &a, const point &b ){
			              return a.x * b.y - a.y * b.x;
			        }
![det](http://f.hiphotos.baidu.com/image/w%3D2048%3Bq%3D90/sign=c0dae43ab0fb43161a1f7d7a149c7d52/bd3eb13533fa828b5ba91912ff1f4134960a5abd.jpg "det")
```
			        //从第一象限开始逆时针极角排序
			        friend bool operator < ( const point &a, const point &b ){
			               int ret = cmp( det( a, b ) );	//det < 0 =〉逆时针
			               if( a.y * b.y < 0 )	
			                        return ret < 0 && a.y < b.y;
			               return ret < 0 || ret == 0 && cmp( a.x - b.x) < 0;
			        }
			}
		}
		//点积
		double dot( point a, point b ){
		        return a.x * b.x + a.y * b.y;
		}
		//两个点的距离
		double norm( const point &a ){
		    return sqrt(a.x*a.x + a.y*a.y);
		}
		//向量oa绕原点逆时针旋转t（弧度）
		point rotatep( const point &a, double t ){
		        double tx = a.x, ty = a.y;
		        return point(tx*cos(t)-ty*sin(t), tx*sin(t)+ty*cos(t));
		}
```
###线类
		struct line{
			point s, t;
			line(){}
        		line( point a, point b ):s(a), t(b){}
		}
		//点到线段st的最短距离
		double dist( const point &p, const point &s, const point &t ){
		    if( cmp(dot(p-s, t-s)) < 0 ) return norm( p-s );
		    if( cmp(dot(p-t, s-t)) < 0 ) return norm( p-t );
		    return fabs(det( p-s, p-t ) / norm(s-t));
		}
		point ProjLine( point p, point s, point t ){
			double r = dot((t-s), (p-s)) / dot( t-s, t-s );
			return s+r*(t-s);
		}
		//两条线段的交点
		point makepoint( line l1, line l2 ){
		        double s1, s2;
		        s1 = det( l1.s - l2.t, l2.t - l2.s );
		        s2 = det( l1.t - l2.t, l2.t - l2.s );
		        return ( s1 * l1.t - s2 * l1.s ) / ( s1 - s2 );
		}
		//判断两条直线的关系
		int parallel( line l1,  line l2 ){
		        if( cmp( det(l1.t - l1.s, l2.t-l2.s) ) == 0 ){
		                double r1, r2, r3, r4;
		                 r1 = det( l1.s - l2.s, l1.s-l2.t );
		                 r2 = det( l1.t - l2.s, l1.t - l2.t );
		                 r3 = det( l2.s - l1.s, l2.s - l1.t );
		                 r4 = det( l2.t - l1.s, l2.t - l1.t );
		                 if( r1*r2 == 0 && r3*r4 == 0 )
		                        return 1;	//重合
		                else
		                        return 0;	//平行
		        }
		        return 2;			//相交
		}
		//判断点p是否在线段l上
		bool pons( point p, line l ){
		        return cmp( det(p-l.s, l.t-l.s) ) == 0  && cmp( dot( p-l.s, p-l.t) ) <= 0;
		}
![intersect](http://h.hiphotos.baidu.com/image/w%3D2048%3Bq%3D90/sign=ab4cdfc71f950a7b753549c43ee959a8/2cf5e0fe9925bc31bb2485695cdf8db1ca1370c2.jpg)

```
		//判断两条线段的关系
		bool intersect( line l1, line l2 ){
		        double r1, r2, r3, r4;
		         r1 = det( l1.s - l2.s, l1.s-l2.t );
		         r2 = det( l1.t - l2.s, l1.t - l2.t );
		         r3 = det( l2.s - l1.s, l2.s - l1.t );
		         r4 = det( l2.t - l1.s, l2.t - l1.t );
		         if( r1 * r2 <= 0 && r3 * r4 <= 0 ){
		                if( r1*r2== 0 && r3*r4 == 0 && !pons(l1.s, l2) && !pons(l1.t, l2) && !pons( l2.s, l1) && !pons( l2.t, l1 ) )	//判断直线重合情况下，线段是否重合（若彼此两条线段都没有交点则不重合，即不相交）
		                        return false;		
		                return true;	//相交
		         }
		         return false;		//不相交
		}
		//将直线a沿法向量方向平移len得到直线
		line move_d( line a, line b, double len ){
			point d = a.t-a.s;
			d = d/norm(d);
			d = rotatep( d, pi/2 );
			return line(a.s+d*len, a.b+d*len);
		}
```
###凸包
![convex_hull](http://g.hiphotos.baidu.com/image/w%3D2048%3Bq%3D90/sign=982ba314af6eddc426e7b3fb0de38d8c/500fd9f9d72a6059b3f26ceb2a34349b023bba65.jpg)
__凸包的创建__
```
		bool cmp_updown( const point &a, const point &b ){
		    return cmp(a.x-b.x) < 0 || cmp(a.x-b.x) == 0 && cmp(a.y-b.y) < 0;
		 }
		 void convex_hull(){
		    p.resize(2*a.size()+5);
		    sort( a.begin(), a.end(), cmp_updown );
		    a.erase(unique(a.begin(), a.end()), a.end());
		    int m = 0;
		    for( int i = 0; i < a.size(); ++i ){
		        while( m>1 && cmp(det(p[m-1]-p[m-2], a[i]-p[m-2])) <= 0 )
		            --m;
		        p[m++] = a[i];
		    }
		    int k = m;
		    for( int i = int(a.size()-2); i >= 0; i-- ){
		        while( m >k && cmp(det(p[m-1]-p[m-2], a[i]-p[m-2])) <= 0 )
		            --m;
		        p[m++] = a[i];
		    }
		    p[m++] = p[0];
		    p.resize(m);
		    if( a.size() > 1 )
		        p.resize(m-1);
		 }
		 注：用a中的点求出的凸包，行成的凸包的点逆时针存在p中。对于输入没有特别要求
		 
```
__判断点是否在多边形中__
```
		bool containon( const point &b ){
		        int n = p.size();
		        int sign=0;
		        for( int j = 1; j < n; j++  ){
		                if( sign == 0 ){
		                        sign = cmp( det( b-p[j-1], p[j-1]-p[j] ) );
		                        continue;
		                }
		                if( sign * cmp( det( b-p[j-1], p[j-1]-p[j] ) ) < 0 )
		                        return false;
		        }
		        return true;
		}
		注：判断点b是否在多边形p中
```
__多边形面积__
```
		double area(){
		        double sum = 0;
		        for( int j = 1; j < p.size(); j++ ){
		                sum += det( p[j-1], p[j] );
		        }
		        return fabs(sum / 2.);
		}
```
__多边形重心__
```
		point masscenter(){
		        point ans = point( 0, 0 );
		        int s = a.size();
		        for( int i = 0; i < s; i++ )
		                ans = ans +( a[i] + a[(i+1)%s] ) * det( a[(i+1)%s], a[i] );
		        return ans/area()/6.;
		}
```
__点在直线两端点之间__
![afford](http://f.hiphotos.baidu.com/image/w%3D2048%3Bq%3D90/sign=52d4249b272dd42a5f0906ab370360c4/b812c8fcc3cec3fd79fdd687d488d43f86942704.jpg)
```
		bool afford( point s, point t ){
        		return cmp(dot(c-s, t-s)) > 0 && cmp(dot(c-t, s-t)) > 0 );
		}
```
###
